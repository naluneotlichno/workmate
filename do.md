# Roadmap (План работ)

## Базовая инфраструктура
+ Проанализировать требования и уточнить спорные моменты из TZ.md
+ Создать структуру проекта
+ Реализовать in-memory хранилище для задач (без БД) с JSON-снепшотами на диске
    + Стейт задач пишется в data/tasks/<id>/status.json
    + Архивы складываются в data/tasks/<id>/archive.zip (по папке на задачу)
+ Логирование (zerolog + Gin middleware)

## API
+ Спроектировать структуру API: эндпоинты для создания задач, добавления файлов, проверки статуса (описаны в README)
+ Реализовать эндпоинт для создания новой задачи (с отказом при занятом семафоре)
+ Реализовать эндпоинт для добавления ссылок на файлы (валидация расширений и лимит 3)
+ Реализовать эндпоинт получения статуса задачи
+ Реализовать эндпоинт скачивания архива

## Бизнес-логика
+ Скачивание файлов, фильтрация по .pdf/.jpeg, обработка ошибок недоступных ссылок
+ Архивация доступных файлов и отражение ошибок по каждому URL в статусе
+ Ограничение одновременной обработки (MaxConcurrentTasks=3 по умолчанию)
+ Автозапуск обработки при добавлении 3-го файла
- Запуск обработки «по запросу статуса, если файлов уже три» (не требуется, стартуем при добавлении)

## Конфигурация и документация
+ Конфиг (port, data_dir, allowed_extensions, max_concurrent_tasks), 8080 по умолчанию
+ README.md с описанием API/конфига/запуска
+ Тестирование основных эндпоинтов и edge-cases (см. internal/api/handlers_test.go)

## Логирование
+ Подробное логирование запросов и событий задач (zerolog)
- Хранение логов в отдельной папке (сейчас вывод в консоль)



---

# Функциональные требования

## 1. Поддерживаемые типы файлов

+ Только .pdf и .jpeg (без .jpg, без других форматов)
+ Расширение не чувствительно к регистру (.PDF, .jpeg — ок)

## 3. Недоступные ссылки

+ Если файл не скачался — в архив не попадает
+ Задача считается завершённой, если хотя бы один файл скачался
+ В ответе на статус задачи указываю, какие ссылки не удалось скачать (список ошибок)

## 4. Статус задачи и архив

+ Архив формируется автоматически при добавлении третьего файла
- Запуск при запросе статуса, если файлов уже три (не реализовано, т.к. стартуем на добавлении)
+ Если хотя бы один файл скачался — архив создаётся из доступных файлов, остальные — в ошибках

## 6. Хранение архивов

- Архивы хранятся до первого скачивания (сейчас: сохраняются на диск в data/tasks/<id>/archive.zip)
- После скачивания архив удаляется (сейчас: не удаляем)


## 5. Лимит на 3 задачи

+ Одновременно “в работе” могут быть только 3 задачи, где ещё не выдан архив (то есть, статус не “готово”)
+ Как только архив выдан (или задача завершена с ошибками) — слот освобождается

---

# Технические детали

+ Все ответы — в JSON
- Для ошибок отдельное поле errors (массив строк) — сейчас используем поле error (string) в ответах-ошибках
+ Для успешных операций — поле archive_url (если архив готов), status (текущий статус задачи), files (список добавленных файлов)
- Лимит на 3 задачи и 3 файла на пользователя (по IP) — глобальный лимит и лимит файлов в задаче есть; per-IP лимита нет

---

# Конфиг

+ Расширения и порт (8080 по умолчанию) задаются через конфиг-файл (config.yml)


Если нехуй делать:
 - Реализовать парочку алгосов что бы сделать код более эффективным
 - Заебенить нейросеть чтобы она обучалась на поступающих данных. Хз что делать но хуй там
 - Реализовать ML с данными.
 - 